"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[5599],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),d=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=d(e.components);return a.createElement(l.Provider,{value:n},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(t),h=r,m=c["".concat(l,".").concat(h)]||c[h]||p[h]||o;return t?a.createElement(m,i(i({ref:n},u),{},{components:t})):a.createElement(m,i({ref:n},u))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=t[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},40337:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=t(87462),r=(t(67294),t(3905));const o={id:"dispatchable",title:"Creating dispatchable functions",sidebar_label:"Creating dispatchable functions",description:"Creating dispatchable functions for our pallet."},i=void 0,s={unversionedId:"Substrate/section5/dispatchable",id:"Substrate/section5/dispatchable",title:"Creating dispatchable functions",description:"Creating dispatchable functions for our pallet.",source:"@site/docs/Substrate/section5/dispatchable.md",sourceDirName:"Substrate/section5",slug:"/Substrate/section5/dispatchable",permalink:"/docs/Substrate/section5/dispatchable",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Substrate/section5/dispatchable.md",tags:[],version:"current",lastUpdatedBy:"davidsemakula",lastUpdatedAt:1703552998,formattedLastUpdatedAt:"Dec 26, 2023",frontMatter:{id:"dispatchable",title:"Creating dispatchable functions",sidebar_label:"Creating dispatchable functions",description:"Creating dispatchable functions for our pallet."},sidebar:"substrate",previous:{title:"Building a FRAME Pallet",permalink:"/docs/Substrate/section5/"},next:{title:"Writing unit tests for pallets",permalink:"/docs/Substrate/section5/unit-tests"}},l={},d=[{value:"Adding the <code>register</code> dispatchable",id:"adding-the-register-dispatchable",level:2},{value:"Defining our sender and function",id:"defining-our-sender-and-function",level:3},{value:"Checking balance and using <code>ensure!</code> to check requirements",id:"checking-balance-and-using-ensure-to-check-requirements",level:3},{value:"Unbounded to bounded",id:"unbounded-to-bounded",level:3},{value:"Generate a gradient profile and build our user",id:"generate-a-gradient-profile-and-build-our-user",level:3},{value:"Lock balance and store our user",id:"lock-balance-and-store-our-user",level:3},{value:"Update the total amount of users on the network",id:"update-the-total-amount-of-users-on-the-network",level:3},{value:"Emit an event",id:"emit-an-event",level:3},{value:"Full <code>register</code> function",id:"full-register-function",level:3}],u={toc:d},c="wrapper";function p(e){let{components:n,...t}=e;return(0,r.kt)(c,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"With all of our tools in place to register a user, let's go through the process of adequately\nregistering them via an ",(0,r.kt)("strong",{parentName:"p"},"extrinsic")," or state change."),(0,r.kt)("admonition",{title:"What is an extrinsic again?",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"An extrinsic is a transaction or a unit to define how the state should change within the network.")),(0,r.kt)("h2",{id:"adding-the-register-dispatchable"},"Adding the ",(0,r.kt)("inlineCode",{parentName:"h2"},"register")," dispatchable"),(0,r.kt)("p",null,"Navigate to the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[pallet::call]")," macro; it should be empty:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[pallet::call]\nimpl<T: Config> Pallet<T> {\n    // Our dispatchable goes here.\n}\n")),(0,r.kt)("p",null,"We are going to create a function called ",(0,r.kt)("inlineCode",{parentName:"p"},"register"),", which will take several parameters/factors into\nconsideration and perform the following checks:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Take a parameter, ",(0,r.kt)("inlineCode",{parentName:"li"},"name"),", of the user. The character amount must be below ",(0,r.kt)("inlineCode",{parentName:"li"},"MaxNameLength"),"."),(0,r.kt)("li",{parentName:"ul"},"Take a parameter, ",(0,r.kt)("inlineCode",{parentName:"li"},"bio"),", of the user. The character amount must be below ",(0,r.kt)("inlineCode",{parentName:"li"},"MaxBioLength"),"."),(0,r.kt)("li",{parentName:"ul"},"Check if they have enough balance to lock, and if so, lock it. Else, they cannot register."),(0,r.kt)("li",{parentName:"ul"},"Generate a profile picture for our user"),(0,r.kt)("li",{parentName:"ul"},"If the user meets the requirements, we store them in our ",(0,r.kt)("inlineCode",{parentName:"li"},"StorageMap"),"."),(0,r.kt)("li",{parentName:"ul"},"Emit an event that they registered.")),(0,r.kt)("h3",{id:"defining-our-sender-and-function"},"Defining our sender and function"),(0,r.kt)("p",null,"With our requirements adequately defined, we can begin coding this function. Go ahead and paste the\nfunction called ",(0,r.kt)("inlineCode",{parentName:"p"},"register")," that includes some beginning logic to start:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[pallet::call]\nimpl<T: Config> Pallet<T> {\n\n    /// Registers a user to the network.  It requires the balance of the sender to have an amount\n    /// which is greater than or equal to MinimumLockableAmount. Locks MinimumLockableAmount as\n    /// part of the registration process.\n    #[pallet::call_index(0)]\n    pub fn register(origin: OriginFor<T>, name: Vec<u8>, bio: Vec<u8>) -> DispatchResult {\n        let sender = ensure_signed(origin)?;\n    }\n}\n")),(0,r.kt)("h3",{id:"checking-balance-and-using-ensure-to-check-requirements"},"Checking balance and using ",(0,r.kt)("inlineCode",{parentName:"h3"},"ensure!")," to check requirements"),(0,r.kt)("p",null,"A very useful macro, ",(0,r.kt)("inlineCode",{parentName:"p"},"ensure!"),", is provided by FRAME. This macro enables us to check a condition. If\nthe condition proves false, it allows an extrinsic to fail with a specific error."),(0,r.kt)("p",null,"We can also use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Currency")," trait included with our configuration. We will elaborate more on this\ntrait later but know that for now, it enables us to check the balance of the sender:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// Retrieve the "free" balance of the user\nlet balance = T::Currency::free_balance(&sender);\n\n// Before proceeding - we have to make sure the *free* balance of a user is enough to\n// lock up!  Otherwise, we halt this dispatchable with an error.\nensure!(balance >= T::MinimumLockableAmount::get(), Error::<T>::LowBalance);\n')),(0,r.kt)("h3",{id:"unbounded-to-bounded"},"Unbounded to bounded"),(0,r.kt)("p",null,"If you notice, the parameters (",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"bio"),") provided in ",(0,r.kt)("inlineCode",{parentName:"p"},"register")," are of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<u8>"),". This\nis a vector of bytes, which you may now consider a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,r.kt)("p",null,"Within our config, we have two notable constants defined: ",(0,r.kt)("inlineCode",{parentName:"p"},"MaxBioLength")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"MaxNameLength"),". We\nwant our two parameters to be ",(0,r.kt)("strong",{parentName:"p"},"bounded")," to these limits, as we shouldn't allow for infinite values\nto be stored on the chain."),(0,r.kt)("p",null,"The following code does just that and maps the appropriate error if it does exceed this length. We\nuse the type ",(0,r.kt)("inlineCode",{parentName:"p"},"BoundedVec")," to convert from a ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec")," to something that is bounded:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let name_bounded: BoundedVec<u8, T::MaxNameLength> =\n    BoundedVec::try_from(name.clone()).map_err(|_| Error::<T>::NameTooLong)?;\nlet bio_bounded: BoundedVec<u8, T::MaxBioLength> =\n    BoundedVec::try_from(bio).map_err(|_| Error::<T>::BioTooLong)?;\n\n// 2.  Check if the name already exists or user metadata already exists\nensure!(<Names<T>>::get(&name_bounded).is_none(), Error::<T>::NameInUse);\nensure!(\n    <RegisteredUsers<T>>::get(&sender).is_none(),\n    Error::<T>::AccountIdAlreadyRegistered\n);\n")),(0,r.kt)("h3",{id:"generate-a-gradient-profile-and-build-our-user"},"Generate a gradient profile and build our user"),(0,r.kt)("p",null,"We can build our user once we have our parameters converted and ready."),(0,r.kt)("p",null,"Firstly, we can call another trait, ",(0,r.kt)("inlineCode",{parentName:"p"},"T::Randomness"),", to provide a random value to the included\n",(0,r.kt)("inlineCode",{parentName:"p"},"generate_hex_values")," function."),(0,r.kt)("p",null,"This will return two randomly generated hex values that can be used to create a gradient profile\npicture:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// Generate our random profile picture (aka, two hex values that form a gradient)\n// Usually, some increasing nonce is used as a seed.  For simplicity, we use the account\n// id as the seed.\nlet (value, _) = T::Randomness::random(&sender.encode());\nlet random_pfp = Self::generate_hex_values(value);\n\n// Construct our UserMetadata.  Ideally, we could also create an implementation to make\n// this easier to create!\nlet user_metadata: UserMetadata<T> = UserMetadata {\n    name: name_bounded.clone(),\n    bio: bio_bounded,\n    profile_gradient: random_pfp,\n    account_id: sender.clone(),\n};\n")),(0,r.kt)("h3",{id:"lock-balance-and-store-our-user"},"Lock balance and store our user"),(0,r.kt)("p",null,"With our users fully configured, we can now lock their balance and finish the registration process\nby storing them in our ",(0,r.kt)("inlineCode",{parentName:"p"},"RegisteredUsers")," mapping:"),(0,r.kt)("p",null,"We also add the user's name to another mapping of names (",(0,r.kt)("inlineCode",{parentName:"p"},"Names"),") to ensure it doesn't get taken."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// Lock the minimum deposit.  This account will now have this amount locked until\n// they 'de-register'.\nT::Currency::set_lock(\n    LOCK_ID,\n    &sender,\n    T::MinimumLockableAmount::get(),\n    WithdrawReasons::RESERVE,\n);\n\n// Store the user, add to existing names, and update the total amount of users\n<RegisteredUsers<T>>::insert(&sender, user_metadata);\n<Names<T>>::insert(&name_bounded, sender.clone());\n")),(0,r.kt)("h3",{id:"update-the-total-amount-of-users-on-the-network"},"Update the total amount of users on the network"),(0,r.kt)("p",null,"Once we register the user, we can update the total number of users on the network. Note the use of\n",(0,r.kt)("inlineCode",{parentName:"p"},"checked_add")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"unwrap_or_default()"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// Note the use of 'unwrap_or_default' - this is better than just a plain 'unwrap()'\n// The default for 'u32' is 0, meaning an 'unwrap_or(0)' could also work here!\n\nlet total_registered = <TotalRegistered<T>>::get().unwrap_or_default();\n\n// Using checked_add() ensures 'safe math' occurs.\n// Since we never want panic within a runtime, we have to ensure all *possible* errors\n// can be caught.\n\n<TotalRegistered<T>>::put(\n    total_registered.checked_add(1).ok_or(Error::<T>::IntegerOverflow)?,\n);\n")),(0,r.kt)("h3",{id:"emit-an-event"},"Emit an event"),(0,r.kt)("p",null,"Lastly, we can emit an event once everything above is performed to indicate a new user has been\nregistered:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// Emit an event to indicate a new user was added to the network\nSelf::deposit_event(Event::Registered { id: sender });\n")),(0,r.kt)("h3",{id:"full-register-function"},"Full ",(0,r.kt)("inlineCode",{parentName:"h3"},"register")," function"),(0,r.kt)("p",null,"The entire register function should end up looking like this by the end:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    #[pallet::call_index(0)]\n    pub fn register(origin: OriginFor<T>, name: Vec<u8>, bio: Vec<u8>) -> DispatchResult {\n        let sender = ensure_signed(origin)?;\n        let balance = T::Currency::free_balance(&sender);\n\n        // Before proceeding - we have to make sure the *free* balance of a user is enough to\n        // lock up! Otherwise, we halt this dispatchable with an error.\n        ensure!(balance >= T::MinimumLockableAmount::get(), Error::<T>::LowBalance);\n\n        // 1. Craft the user metadata out of the given parameters from `register`.\n        // Keep in mind we have to cast these to `BoundedVec` using the limits we have defined\n        // in our Config (hence why we must access them using our handy `T` generic operator!).\n        // Notice the error handling! Other types of error handling are okay too :)\n\n        let name_bounded: BoundedVec<u8, T::MaxNameLength> =\n            BoundedVec::try_from(name.clone()).map_err(|_| Error::<T>::NameTooLong)?;\n        let bio_bounded: BoundedVec<u8, T::MaxBioLength> =\n            BoundedVec::try_from(bio).map_err(|_| Error::<T>::BioTooLong)?;\n\n        // 2. Check if the name already exists or user metadata already exists\n        ensure!(<Names<T>>::get(&name_bounded).is_none(), Error::<T>::NameInUse);\n        ensure!(\n            <RegisteredUsers<T>>::get(&sender).is_none(),\n            Error::<T>::AccountIdAlreadyRegistered\n        );\n\n        // 3. Generate our random profile picture (aka, two hex values which form a gradient)\n        // Usually, some increasing nonce is used as a seed. For simplicity, we use the account\n        // id as the seed.\n        let (value, _) = T::Randomness::random(&sender.encode());\n        let random_pfp = Self::generate_hex_values(value);\n\n        // 4. Construct our UserMetadata.  Ideally, we could also create an implementation to make\n        // this easier to create!\n        let user_metadata: UserMetadata<T> = UserMetadata {\n            name: name_bounded.clone(),\n            bio: bio_bounded,\n            profile_gradient: random_pfp,\n            account_id: sender.clone(),\n        };\n\n        // 5. Lock the minimum deposit.  This account will now have this amount locked until\n        // they 'de-register'.\n        T::Currency::set_lock(\n            LOCK_ID,\n            &sender,\n            T::MinimumLockableAmount::get(),\n            WithdrawReasons::RESERVE,\n        );\n\n        // 6. Store the user, add to existing names, and update total amount of users\n        <RegisteredUsers<T>>::insert(&sender, user_metadata);\n        <Names<T>>::insert(&name_bounded, sender.clone());\n\n        // Note the use of 'unwrap_or_default' - this is better than just a plain 'unwrap()'\n        // The default for 'u32' is 0, meaning an 'unwrap_or(0)' could also work here!\n\n        let total_registered = <TotalRegistered<T>>::get().unwrap_or_default();\n\n        // The use of checked_add() ensures 'safe math' is taking place.\n        // Since we never want panic within a runtime, we have to ensure all *possible* errors\n        // can be caught.\n\n        <TotalRegistered<T>>::put(\n            total_registered.checked_add(1).ok_or(Error::<T>::IntegerOverflow)?,\n        );\n\n        // 7. Emit an event to indicate a new user was added to the network\n        Self::deposit_event(Event::Registered { id: sender });\n\n        Ok(())\n    }\n")))}p.isMDXComponent=!0}}]);