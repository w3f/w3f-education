"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[5605],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),m=r,h=c["".concat(o,".").concat(m)]||c[m]||d[m]||i;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[c]="string"==typeof e?e:r,l[1]=s;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},72342:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const i={id:"data-types",title:"Data Types in Rust",sidebar_label:"Data Types",description:"Learn what data types are and which basic ones exist."},l=void 0,s={unversionedId:"Rust/section2/data-types",id:"Rust/section2/data-types",title:"Data Types in Rust",description:"Learn what data types are and which basic ones exist.",source:"@site/docs/Rust/section2/data-types.md",sourceDirName:"Rust/section2",slug:"/Rust/section2/data-types",permalink:"/docs/Rust/section2/data-types",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Rust/section2/data-types.md",tags:[],version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1696421259,formattedLastUpdatedAt:"Oct 4, 2023",frontMatter:{id:"data-types",title:"Data Types in Rust",sidebar_label:"Data Types",description:"Learn what data types are and which basic ones exist."},sidebar:"rust",previous:{title:"The Heap vs. The Stack",permalink:"/docs/Rust/section2/heap-vs-stack"},next:{title:"Functions & Comments",permalink:"/docs/Rust/section2/functions-comments"}},o={},p=[{value:"Scalar Types",id:"scalar-types",level:2},{value:"Integers &amp; Floating-point Types",id:"integers--floating-point-types",level:3},{value:"Floating point numbers",id:"floating-point-numbers",level:4},{value:"Operators",id:"operators",level:4},{value:"Boolean Types",id:"boolean-types",level:3},{value:"Character Type",id:"character-type",level:3},{value:"Compound Types",id:"compound-types",level:2},{value:"Tuples",id:"tuples",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Try it yourself!",id:"try-it-yourself",level:2},{value:"What is happening here?",id:"what-is-happening-here",level:2}],u={toc:p},c="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"As mentioned before in the introduction of this course, one of Rust's main objectives is to have a\nrobust, compile-time type system. Just as the immutability of variables helps with safety, having\ntypes in Rust greatly aids in ensuring that data is flowing as it should throughout the program."),(0,r.kt)("p",null,"Rust has two kinds of ",(0,r.kt)("strong",{parentName:"p"},"primitive"),", or base, data types:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Scalar - single point types, such as numbers and booleans (",(0,r.kt)("inlineCode",{parentName:"li"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"false")," statements)."),(0,r.kt)("li",{parentName:"ul"},"Compound - arrays and tuples.")),(0,r.kt)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/G9I-HdPsLmo",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),(0,r.kt)("h2",{id:"scalar-types"},"Scalar Types"),(0,r.kt)("p",null,"Scalar types represent a single value, such as a number or boolean. Rust has four core Scalar types,\nwhich you have most likely seen in other programming languages:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Integers"),(0,r.kt)("li",{parentName:"ul"},"Floating-point numbers"),(0,r.kt)("li",{parentName:"ul"},"Booleans"),(0,r.kt)("li",{parentName:"ul"},"Characters")),(0,r.kt)("h3",{id:"integers--floating-point-types"},"Integers & Floating-point Types"),(0,r.kt)("p",null,"An integer in Rust is the same as in mathematics - a non-fractional, whole number that can be either\npositive or negative. There are two types of integers: ",(0,r.kt)("em",{parentName:"p"},"unsigned")," (positive numbers) and ",(0,r.kt)("em",{parentName:"p"},"signed"),"\n(negative ",(0,r.kt)("em",{parentName:"p"},"or")," positive numbers)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Signed integers are denoted by the ",(0,r.kt)("inlineCode",{parentName:"li"},"i"),", followed by the length of the number: ",(0,r.kt)("inlineCode",{parentName:"li"},"i32"),"."),(0,r.kt)("li",{parentName:"ul"},"Unsigned integers start with ",(0,r.kt)("inlineCode",{parentName:"li"},"u,")," followed by the length of the number: ",(0,r.kt)("inlineCode",{parentName:"li"},"u32"),".")),(0,r.kt)("p",null,"The numeric characters ",(0,r.kt)("inlineCode",{parentName:"p"},"32")," that follow whether an integer is signed or unsigned denotes the length\nof the number. Take this table from the\n",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch03-02-data-types.html"},"Rust Book"),", which states all possible\ninteger variants:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Length"),(0,r.kt)("th",{parentName:"tr",align:null},"Signed"),(0,r.kt)("th",{parentName:"tr",align:null},"Unsigned"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"8-bit"),(0,r.kt)("td",{parentName:"tr",align:null},"i8"),(0,r.kt)("td",{parentName:"tr",align:null},"u8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16-bit"),(0,r.kt)("td",{parentName:"tr",align:null},"i16"),(0,r.kt)("td",{parentName:"tr",align:null},"u16")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"32-bit"),(0,r.kt)("td",{parentName:"tr",align:null},"i32"),(0,r.kt)("td",{parentName:"tr",align:null},"u32")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"64-bit"),(0,r.kt)("td",{parentName:"tr",align:null},"i64"),(0,r.kt)("td",{parentName:"tr",align:null},"u64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"128-bit"),(0,r.kt)("td",{parentName:"tr",align:null},"i128"),(0,r.kt)("td",{parentName:"tr",align:null},"u128")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arch"),(0,r.kt)("td",{parentName:"tr",align:null},"isize"),(0,r.kt)("td",{parentName:"tr",align:null},"usize")))),(0,r.kt)("p",null,"The length or size of the integer is always explicitly declared. Rust has a set of defaults for\ninferring types, such as integers defaulting to the ",(0,r.kt)("inlineCode",{parentName:"p"},"i32")," type. ",(0,r.kt)("inlineCode",{parentName:"p"},"usize")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"isize")," depend on your\nmachine's architecture, meaning they are either 32, or 64 bit in size."),(0,r.kt)("p",null,"Here are some common ways to declare an integer, some formats less traditional than others:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\n// Defaults to i32.\nlet default = 10;\n\n// Explicitly declare this variable as an unsigned, 64-bit integer:\nlet sixty_four_bit_int: u64 = 10;\n\n// You can also declare integer literals like so:\nlet big_number = 65_550; // 65,550\n\n// Another way to specify the type can be done with this syntax, with the type following the number:\nlet short_hand = 455u32;\n\n// Declaring a hex literal is possible!\nlet hex = 0x001;\n\n// You can also represent characters as unsigned 8-bit numbers.  This will get very useful later on:\nlet word_as_bytes: u8 = b'F';\n\n")),(0,r.kt)("p",null,"Lastly, as integers do have a size, integer overflow is possible if you exceed the limit of a given\ntype. For example, the type ",(0,r.kt)("inlineCode",{parentName:"p"},"u8")," has a minimum of 0 and a maximum of 255, meaning 256 would cause a\npanic. As the Rust compiler doesn't check for overflows, there are some additional functions you can\nuse to ensure that adding or subtracting is always safe and won't cause a runtime error. We'll learn\nmore about those later on."),(0,r.kt)("h4",{id:"floating-point-numbers"},"Floating point numbers"),(0,r.kt)("p",null,"Rust has two floating number types: ' f32",(0,r.kt)("inlineCode",{parentName:"p"},"(32-bit) and"),"f64` (64-bit). Floating point numbers, unlike\nintegers, are fractional, meaning they contain decimal points to represent parts of whole numbers:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"f32")," has single precision accuracy, whereas ",(0,r.kt)("inlineCode",{parentName:"p"},"f64")," has double-precision accuracy. ",(0,r.kt)("inlineCode",{parentName:"p"},"f64")," is the\ndefault type for floating point numbers in Rust:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet floating_double: f64 = 1.11;\n\nlet floating_single: f32 = 1.4;\n\nlet also_floating_double = 1.45;\n\n")),(0,r.kt)("h4",{id:"operators"},"Operators"),(0,r.kt)("p",null,"As in any other programming language, there are a set of operators that allow for basic mathematics\nto be performed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet addition = 1 + 1; // 2\nlet subtraction = 10 - 5; // 5\nlet division = 8 / 4; // 2\nlet multiplication = 4 * 4; // 16\n\n")),(0,r.kt)("p",null,"Likewise, Rust also supports bitwise operators. A full list of Rust's operators and symbols may be\n",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/appendix-02-operators.html"},"found here.")),(0,r.kt)("h3",{id:"boolean-types"},"Boolean Types"),(0,r.kt)("p",null,"A boolean value can only have two possible states: ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". Declaring a boolean in Rust is\nsimple:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet i_am_true = true;\n\n// Usually, it's easy to infer a bool type; however good to show explicit type assignments.\nlet i_am_false: bool = false;\n\n")),(0,r.kt)("p",null,"This opens up many possibilities for ",(0,r.kt)("strong",{parentName:"p"},"branching logic")," in our Rust programs, of which we'll cover\nlater."),(0,r.kt)("h3",{id:"character-type"},"Character Type"),(0,r.kt)("p",null,"The character, or ",(0,r.kt)("inlineCode",{parentName:"p"},"char")," type in Rust is the basic building block for alphabetic values. It simply\ndeclares a single character, which is encased by single quotes. At its core, it represents a\n",(0,r.kt)("a",{parentName:"p",href:"https://home.unicode.org/"},"Unicode Scalar Value"),", supporting a plethora of characters as well as\nzero-width spaces:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// Both are valid Unicode characters!\nlet the_letter_a = 'A';\nlet the_moon = '\ud83c\udf12';\n")),(0,r.kt)("h2",{id:"compound-types"},"Compound Types"),(0,r.kt)("p",null,"Scalar types define how variables can hold a single value at a time. Compound types can hold\nmultiple values under the same, unifying type."),(0,r.kt)("p",null,"There are two primary kinds of compound types - tuples and arrays."),(0,r.kt)("h3",{id:"tuples"},"Tuples"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"tuple")," is a way to combine multiple values and types into a single, compound type. It can be\nuseful for describing a set of varying values which have some relationship to one another."),(0,r.kt)("p",null,"The syntax for writing a tuple is as follows. Note that the type annotations are optional:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet my_tuple: (u32, f32, char) = (5, 5.5, '\ud83c\udf12'); // The explicit type annotations here are optional,\n\n")),(0,r.kt)("p",null,"There are a couple of ways to access the elements within a tuple. The first way merely involves\nfetching them in order, starting at ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet unsigned_32: u32 = my_tuple.0;\nlet floating_32: f32 = my_tuple.1;\nlet moon: char = my_tuple.2;\n\n")),(0,r.kt)("p",null,"You may also use pattern matching to access these elements. The following syntax constructs a\npattern out of the above:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet my_tuple: (u32, f32, char) = (5, 5.5, '\ud83c\udf12'); // The explicit type annotations here are optional,\n\nlet (unsigned_32, floating_32, moon) = my_tuple;\n")),(0,r.kt)("p",null,"Tuples can have elements that are of varying types, as seen above. They can be useful in describing\na set, fixed amount of elements, such as a set of coordinates:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet location: (i32, i32) = (10, 45);\n\n")),(0,r.kt)("h3",{id:"arrays"},"Arrays"),(0,r.kt)("p",null,"An ",(0,r.kt)("strong",{parentName:"p"},"array")," is a collection of multiple values. Unlike tuples, these values must be the same type.\nArrays are like lists - and are useful for having a fixed amount of types and having data stored on\nthe ",(0,r.kt)("strong",{parentName:"p"},"stack"),"."),(0,r.kt)("p",null,"Arrays are typically used less often than",(0,r.kt)("strong",{parentName:"p"}," vectors"),", which is a type of collection that includes a\nnumber of convenience methods for sorting and manipulating the values within the collection. Vectors\ncan grow and shrink in size, as the data is managed by the ",(0,r.kt)("strong",{parentName:"p"},"heap"),", whereas arrays are fixed-length\nand stored on the stack."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet my_pets_ages: [i32; 3] = [4, 5, 3];\n\n")),(0,r.kt)("p",null,"Notice in the type declaration, ",(0,r.kt)("inlineCode",{parentName:"p"},"[i32; 3]"),", that the first part denotes the type of ",(0,r.kt)("strong",{parentName:"p"},"each element"),"\nwithin the array with each type being an ",(0,r.kt)("inlineCode",{parentName:"p"},"i32"),". The second portion within the square brackets, ",(0,r.kt)("inlineCode",{parentName:"p"},"3"),",\ndenotes the ",(0,r.kt)("strong",{parentName:"p"},"maximum amount of elements an array can hold"),". It's possible to do without this\nexplicit declaration, as the compiler will interpret it as it stands."),(0,r.kt)("p",null,"To access specific elements within an array is done using square brackets, along with the index of\nthe element you wish to access. As with tuples, all arrays start at index ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'\nlet course_modules = ["Module 1", "Module 2", "Module 3","Module 4", "Module 5"];\n// Use the [ index ] syntax to access a particular element.\nlet module_one = course_modules[0];\n')),(0,r.kt)("p",null,"Be forewarned - it's possible to access an element that doesn't exist, which would cause a runtime\nerror."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nerror: this operation will panic at runtime\n  --\x3e src/main.rs:32:18\n   |\n32 | let module_six = course_modules[5];\n   |                  ^^^^^^^^^^^^^^^^^ index out of bounds: the length is 5 but the index is 5\n   |\n   = note: `#[deny(unconditional_panic)]` on by default\n\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"How can the Rust compiler know when a runtime error will occur? Because an array is fixed length, it\nknows the maximum index that can be accessed, in this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"4"),". The compiler disallows it before\nthe program is even compiled. However, if this index is a user-generated value, which can only exist\nat runtime, then a panic will occur and the program will stop. The fact that the program stops is a\nsecurity measure as it prevents any possibly invalid memory from being accessed and exploited.")),(0,r.kt)("h2",{id:"try-it-yourself"},"Try it yourself!"),(0,r.kt)("iframe",{width:"100%",height:"580",src:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=%2F%2F+As+always%2C+start+with+an+entry+point+into+our+program%0Afn+main%28%29+%7B%0A%0A%2F%2F+Let%27s+start+by+creating+a+list%2C+or+an+array+of+the+course%27s+modules%3A%0A%0Alet+course_modules+%3D+%5B%22Module+1%22%2C+%22Module+2%22%2C+%22Module+3%22%2C%22Module+4%22%2C+%22Module+5%22%5D%3B%0A%0A%2F%2F+Next%2C+let%27s+print+each+one+out+till+it+reaches+the+end.+You%27ll+learn+about+loops%2C+but+just%0A%2F%2F+know+that+this+goes+over+each+element+within+the+array+until+it%27s+finished.%0A++++for+module+in+course_modules+%7B%0A++++++++println%21%28%22%7Bmodule%7D%22%29%0A++++%7D%0A%2F%2F+Great%2C+it+prints%21+Now%2C+suppose+we+try+to+add+another+element+to+the+array.%0A%2F%2F+This+is+done+using+the+%60.push%60+method+to+append%2C+or+push+another+element.%0A%2F%2F+course_modules.push%28%22Module+6%22%29%3B%0A%0A%2F%2F+It+doesn%27t+compile%21+Can+you+read+the+message+and+figure+out+why%3F%0A%0A%2F%2F+Lets+use+our+knowledge+of+shadow+variables+and+remake+this+array.%0A%2F%2F+We+can+see+that+the+compiler+states+that+it+is+%60%5B%26str%3B+5%5D%60%2C+meaning%0A%2F%2F+It+was+expecting+5+elements%2C+not+6%2C+hence+it+panicked+when+we+added+the+sixth+module.%0A%0A%2F%2F+Try+creating+an+array+of+tuples%2C+and+printing+them+as+we+did+above.+%0A%2F%2F+Don%27t+forget+to+comment+out+or+remove+the+line+that+breaks+the+program%0A%0Alet+tuple_array+%3D+%5B%28%22hi%22%2C+3%29%5D%3B%0A+++for+tuple+in+tuple_array+%7B%0A++++++++println%21%28%22%7B%3A%3F%7D%22%2C+tuple%29%0A++++%7D%0A%7D"}),(0,r.kt)("h2",{id:"what-is-happening-here"},"What is happening here?"),(0,r.kt)("p",null,"We define an array a fixed-length list of values of the same type stored on the stack. We can\nsuccessfully access and print the items in this list; however, the compiler prevents any\nout-of-bounds access. It also prevents any additional items from being appended, as the array has a\nfixed length in memory."),(0,r.kt)("p",null,"Next, we create an array of ",(0,r.kt)("em",{parentName:"p"},"tuples"),", which would look like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'\nlet tuple_array = [("hi", 3), ("hello", 1)];\n   for tuple in tuple_array {\n        println!("{:?}", tuple)\n    }\n\n')))}d.isMDXComponent=!0}}]);