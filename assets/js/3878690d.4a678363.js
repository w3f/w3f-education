"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[5137],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>h});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var o=n.createContext({}),u=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},m=function(e){var t=u(e.components);return n.createElement(o.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),p=u(a),d=i,h=p["".concat(o,".").concat(d)]||p[d]||c[d]||r;return a?n.createElement(h,l(l({ref:t},m),{},{components:a})):n.createElement(h,l({ref:t},m))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[p]="string"==typeof e?e:i,l[1]=s;for(var u=2;u<r;u++)l[u]=a[u];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},27377:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var n=a(87462),i=(a(67294),a(3905));const r={id:"variables-mutability",title:"Variables & Mutability",sidebar_label:"Variables & Mutability",description:"How variables and mutability works in Rust."},l=void 0,s={unversionedId:"Rust/section2/variables-mutability",id:"Rust/section2/variables-mutability",title:"Variables & Mutability",description:"How variables and mutability works in Rust.",source:"@site/docs/Rust/section2/variables-mutability.md",sourceDirName:"Rust/section2",slug:"/Rust/section2/variables-mutability",permalink:"/docs/Rust/section2/variables-mutability",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Rust/section2/variables-mutability.md",tags:[],version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1693238811,formattedLastUpdatedAt:"Aug 28, 2023",frontMatter:{id:"variables-mutability",title:"Variables & Mutability",sidebar_label:"Variables & Mutability",description:"How variables and mutability works in Rust."},sidebar:"rust",previous:{title:"Rust Basics",permalink:"/docs/Rust/section2/basics-index"},next:{title:"The Heap vs. The Stack",permalink:"/docs/Rust/section2/heap-vs-stack"}},o={},u=[{value:"Immutability in Rust",id:"immutability-in-rust",level:2},{value:"Shadowing in Rust",id:"shadowing-in-rust",level:2},{value:"Constants in Rust",id:"constants-in-rust",level:2},{value:"Try it out!",id:"try-it-out",level:2},{value:"What is happening here?",id:"what-is-happening-here",level:2}],m={toc:u},p="wrapper";function c(e){let{components:t,...a}=e;return(0,i.kt)(p,(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/eE5x17yRzUA",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),(0,i.kt)("p",null,"If you have ever used another programming language, the concept of ",(0,i.kt)("strong",{parentName:"p"},"variables")," should be familiar."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// A couple Rust variables.\n// The first holds a name (a slice of text), and the other, an age (a number).\nlet my_name: &str = "Bader";\nlet age: u32 = 22;\n// We\'ll dive more into this line later, but just know that it is a way to print information.\nprintln!("My name is {my_name} and I am {age} years old.");\n')),(0,i.kt)("p",null,"As in other languages, variables in Rust behave mostly the same with the exception of a few unique\nproperties, the most prominent being ",(0,i.kt)("strong",{parentName:"p"},"mutability")," and ",(0,i.kt)("strong",{parentName:"p"},"shadowing")," ."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"All variables in Rust are immutable by default. Immutable variables cannot be changed unless\nexplicitly declared as mutable. This prevents unwanted changes to values in code.")),(0,i.kt)("h2",{id:"immutability-in-rust"},"Immutability in Rust"),(0,i.kt)("p",null,"As mentioned before, by default, all variables in Rust are immutable. This means that once a\nvariable has been declared, the value within cannot be changed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// The compiler won't allow this to be changed.\n// This code would throw an error!\n\nlet age: u32 = 22;\n// Increment the age by one.\nage += 1;\n\n======\n\nerror[E0384]: cannot assign twice to immutable variable `age`\n  --\x3e src/main.rs:26:1\n   |\n24 | let age: u32 = 22;\n   |     ---\n   |     |\n   |     first assignment to `age`\n   |     help: consider making this binding mutable: `mut age`\n25 | // Increment the age by one.\n26 | age += 1;\n   | ^^^^^^^^ cannot assign twice to an immutable variable\n")),(0,i.kt)("p",null,"This is yet another example of how the Rust compiler prevents any illegal operations, along with a\ndescriptive way of letting the developer know. The most interesting line to note is\n",(0,i.kt)("inlineCode",{parentName:"p"},"cannot assign twice to immutable variable"),", as this clearly shows the immutability property of the\nvariable."),(0,i.kt)("p",null,"This same error is actually incredibly useful, as in some cases, we sometimes want to keep the value\nof a variable the same. The Rust compiler, by default, keeps this ",(0,i.kt)("em",{parentName:"p"},"safe")," by keeping it immutable.\nThere are many practical reasons for this, i.e., multi-developer projects, where one developer can\nsee the program's intentions by whether a variable is mutable."),(0,i.kt)("p",null,"A variable's value changing unintentionally can also cause trivial bugs, but luckily the Rust\ncompiler deals with it elegantly using immutability."),(0,i.kt)("p",null,"Of course, variables aren't always meant to be immutable. To allow a variable to become mutable, use\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"mut")," keyword before the variable name when declaring it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// This works now!  Notice the `mut`, short for mutable, after `let`\nlet mut age: u32 = 22;\n// Increment the age by one.\nage += 1;\n")),(0,i.kt)("h2",{id:"shadowing-in-rust"},"Shadowing in Rust"),(0,i.kt)("p",null,"Along with variability, Rust introduces the concept of ",(0,i.kt)("strong",{parentName:"p"},"shadowing"),". Take a look at this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'let x = 10u32;\nlet x: &str = "Hello!";\n\n// Prints "Hello!"\nprintln!("{x}");\n')),(0,i.kt)("p",null,"At first glance, this may seem odd - why are there two variables with the same name ",(0,i.kt)("em",{parentName:"p"},"and")," different\ntype? Shouldn't Rust's type system prevent this from occurring?"),(0,i.kt)("p",null,"This is what's called shadowing. The Rust compiler will take the latest value assigned to that\nvariable name, in this case from the number ",(0,i.kt)("inlineCode",{parentName:"p"},"10")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello!"),", and utilize that until either the\nscope ends or it is shadowed again."),(0,i.kt)("p",null,"Shadowing is not the same as declaring a variable mutable with ",(0,i.kt)("inlineCode",{parentName:"p"},"mut"),", as it remains immutable after\nbeing shadowed. The ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," keyword must also be used to shadow a variable, take a look at the\nfollowing example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'\nlet x = 10u32;\nx = "Hello!";\n\n')),(0,i.kt)("p",null,"The above code will fail to compile, as no new assignment is being made via ",(0,i.kt)("inlineCode",{parentName:"p"},"let"),". It is trying, in\nessence, to assign a number of type ",(0,i.kt)("inlineCode",{parentName:"p"},"u32")," to a slice of text."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'\nCompiling playground v0.0.1 (/playground)\nerror[E0308]: mismatched types\n --\x3e src/main.rs:3:5\n  |\n2 | let x = 10u32;\n  |         ----- expected due to this value\n3 | x = "Hello!";\n  |     ^^^^^^^^ expected `u32`, found `&str`\n\n')),(0,i.kt)("p",null,"Shadowing with ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," reassigns the variable to a new type and value, redefining it altogether."),(0,i.kt)("h2",{id:"constants-in-rust"},"Constants in Rust"),(0,i.kt)("p",null,"As with traditional, immutable variables in Rust, ",(0,i.kt)("strong",{parentName:"p"},"constants")," are also immutable - permanently.\nConstants in Rust cannot be made into mutable variables with ",(0,i.kt)("inlineCode",{parentName:"p"},"mut"),". Another difference is that\nconstants only may be set to a constant expression, meaning the value is hardcoded and not\ncalculated as the result of some function in runtime."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"\nconst THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n\n")),(0,i.kt)("p",null,"The naming convention for constants is all uppercase, with underscores between each word. They can\nbe used for declaring some standard, global, and constant variables within your Rust program."),(0,i.kt)("h2",{id:"try-it-out"},"Try it out!"),(0,i.kt)("p",null,"Try out some of these concepts yourself! There are a few things that may seem unfamiliar here, which\nwill be covered on the next page, however - have a look at the code and familiarize yourself:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"u32")," means that a variable is a number."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"&str")," means that the variable is a string literal.")),(0,i.kt)("iframe",{width:"100%",height:"580",src:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=%2F%2F+%0Afn+main%28%29+%7B%0A%0A%2F%2F+We+start+by+creating+two+variables+-+one+is+mutable.%0A%2F%2F+In+the+context+of+this+program%2C+it+makes+sense+-+an+age+can+change%2C%0A%2F%2F+but+a+name+never+usually+changes.%0A%0Alet+mut+age%3A+%26str+%3D+%2222%22%3B%0Alet+name%3A+%26str+%3D+%22Bader%22%3B%0A%0Aprintln%21%28%22%7Bname%7D%3A+%7Bage%7D%22%29%3B%0A%0A%2F%2F+Seems+there+is+a+problem.+Notice+the+age+isnt%27+a+number%2C+but+a+string+of+text%21%0A%2F%2F+It%27s+rather+cumbersome+to+have+to+add+numbers+to+strings+-+not+to+mention+very+impractical.%0A%2F%2F+How+can+we+change+that%3F%0A%0A%2F%2F+To+turn+a+string+into+a+number%2C+we+can+use+the+following+syntax%3A+%0A%2F%2F+age.parse%28%29.unwrap%28%29%3B%0A%2F%2F+Write+a+variable+that+shadows+the+existing+%60age%60+variable+as+a+number.%0A%2F%2F+Make+sure+you+declare+it+as+mutable.%0A%2F%2F+Lastly%2C+add+one+to+it+to+increment+the+age+%28one+year+as+passed%21%29%0A%0Alet+mut+age%3A+u32+%3D+age.parse%28%29.unwrap%28%29%3B%0Aage+%2B%3D+1%3B%0Aprintln%21%28%22%7Bname%7D%3A+%7Bage%7D%22%29%3B%0A%0A%2F%2F+What+has+changed+here%3F+Hint%3A+Take+a+look+at+age+and+see%21%0A%0A%7D"}),(0,i.kt)("h2",{id:"what-is-happening-here"},"What is happening here?"),(0,i.kt)("p",null,"Three primary concepts are being put to use here - namely, ",(0,i.kt)("strong",{parentName:"p"},"immutability")," and ",(0,i.kt)("strong",{parentName:"p"},"shadowing"),".\nInitially, we declare two variables - ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"age"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"age")," is mutable, as age is expected to\nchange, however, a name is meant to be immutable. However, ",(0,i.kt)("inlineCode",{parentName:"p"},"age")," is set to a type that we can't add\nto easily."),(0,i.kt)("p",null,"This is where shadowing comes into play. Using shadowing, redefine ",(0,i.kt)("inlineCode",{parentName:"p"},"age")," to be a number of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"u32")," instead. This allows us to add to the age easily."))}c.isMDXComponent=!0}}]);