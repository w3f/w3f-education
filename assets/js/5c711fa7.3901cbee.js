"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[5805],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),m=i,h=c["".concat(l,".").concat(m)]||c[m]||u[m]||r;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5619:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={id:"alt-data-types",title:"Alternative Data Types",sidebar_label:"Alternative Data Types",description:"Learn when, and how to use non-typical data types"},o=void 0,s={unversionedId:"Rust/section2/alt-data-types",id:"Rust/section2/alt-data-types",title:"Alternative Data Types",description:"Learn when, and how to use non-typical data types",source:"@site/docs/Rust/section2/alt-data-types.md",sourceDirName:"Rust/section2",slug:"/Rust/section2/alt-data-types",permalink:"/docs/Rust/section2/alt-data-types",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Rust/section2/alt-data-types.md",tags:[],version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1697124528,formattedLastUpdatedAt:"Oct 12, 2023",frontMatter:{id:"alt-data-types",title:"Alternative Data Types",sidebar_label:"Alternative Data Types",description:"Learn when, and how to use non-typical data types"},sidebar:"rust",previous:{title:"Extended Basics",permalink:"/docs/Rust/section2/extended-index"},next:{title:"Useful Traits - Common Substrate Traits",permalink:"/docs/Rust/section2/common-traits"}},l={},p=[{value:"Using Larger Data Types",id:"using-larger-data-types",level:2},{value:"&quot;Deterministic&quot; Data Types - Floating Point Numbers",id:"deterministic-data-types---floating-point-numbers",level:2},{value:"Negative Numbers - Unsigned Integers vs. Signed Integers",id:"negative-numbers---unsigned-integers-vs-signed-integers",level:2},{value:"Context-driven types",id:"context-driven-types",level:3},{value:"A Deeper Look at Scalar &amp; Compound Types",id:"a-deeper-look-at-scalar--compound-types",level:2},{value:"Type Aliases",id:"type-aliases",level:3},{value:"Regarding &quot;Sized&quot; Types",id:"regarding-sized-types",level:3},{value:"Why does this matter?",id:"why-does-this-matter",level:3}],d={toc:p},c="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{title:"This page is under construction",type:"warning"}),(0,i.kt)("p",null,"Rust's primitive data types can form the basis for more complex data types. These data types are\ncustom, but are provided when certain primitive types are not able to accommodate some special\nscenarios."),(0,i.kt)("p",null,"In the Polkadot SDK, a great example of this is usage of the ",(0,i.kt)("inlineCode",{parentName:"p"},"sp_arithmetic")," crate, which provides\nminimal, redefined primitives for basic types related to numerics specifically for Susbtrate-based\nblockchain runtimes."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"sp_core"),", another crate, provides predefined types for dealing with cryptographic primitives or\nlarge numbers. Let's explore how to access and use these data types, and why they're useful in the\ncontext of runtime development."),(0,i.kt)("admonition",{title:"Confused on what is going on?",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Anytime you feel lost, make sure to read the tip right below any new concepts that are introduced!")),(0,i.kt)("h2",{id:"using-larger-data-types"},"Using Larger Data Types"),(0,i.kt)("p",null,"When wanting to represent very large numbers, such as a ",(0,i.kt)("em",{parentName:"p"},"hash")," or even an elliptic-curve derived\npublic or private key, it often requires up to 256 bits of data. However, the Rust standard library\nsupplies data types up to ",(0,i.kt)("inlineCode",{parentName:"p"},"u128"),", or 128-bit long numbers. An alternative is by using an existing\ndata structure, such as a ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),", however this could be costly, as well as cumbersome process when\nreading it later."),(0,i.kt)("p",null,"These very large numbers are able to be accommodated by using external types. While these may be\nslower to process, in cryptographic contexts, it allows us to represent complex numbers numerically."),(0,i.kt)("p",null,"Some Substrate libraries, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"sp_core"),", provide primitives for dealing with these large\nnumbers. Let's take a look at ",(0,i.kt)("inlineCode",{parentName:"p"},"U256"),", aka a 256-bit integer type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct U256(pub [u64; 4]);\n")),(0,i.kt)("admonition",{title:"Why is a number a struct?",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Because Rust cannot just simply store an entire 256-bit number in one variable, a custom data type\nhas to be created. This particular type, ",(0,i.kt)("inlineCode",{parentName:"p"},"U256"),", actually stores ",(0,i.kt)("em",{parentName:"p"},"four")," ",(0,i.kt)("inlineCode",{parentName:"p"},"u64")," numbers.")),(0,i.kt)("p",null,"In cryptographic contexts, this is especially, useful, as we can now represent 256-bit numbers\nnumerically."),(0,i.kt)("h2",{id:"deterministic-data-types---floating-point-numbers"},'"Deterministic" Data Types - Floating Point Numbers'),(0,i.kt)("p",null,"Floating point numbers have presented issues in traditional computing for decades. To summarize,\nfloating point calculations are not deterministic, as different architectures may calculate the end\nresult differently - a 32-bit system will calculate a floating point number differently from a\n64-bit system.\n",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=PZRI1IfStY0"},"This video goes into more depth about the issues presented here."),"."),(0,i.kt)("p",null,"While in ",(0,i.kt)("em",{parentName:"p"},"most")," cases, an inaccuracy to the 100th or 1000th place is not a terrible thing, in the\ncase of dealing with things such as balances in a blockchain, floating point rounding errors could\neasily result in different nodes calculating different balances and potentially never reaching a\nconsensus!"),(0,i.kt)("p",null,"For this reason, the notion of floating point primitives, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"f32")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"f64"),", cannot, and\nshould not, be used in the context of the blockchain runtime."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"sp-arithmetic")," provides data types to deal with numbers less than zero, and allows them to be dealt\nsafely in runtime. Unlike floating point arithmetic, which is not deterministic, these data types\nallow fixed point arithmetic. Fixed point arithmetic provides a uniform, deterministic result, as\nthey operate on parts of a whole rather than the relative nature of floating point arithmetic."),(0,i.kt)("h2",{id:"negative-numbers---unsigned-integers-vs-signed-integers"},"Negative Numbers - Unsigned Integers vs. Signed Integers"),(0,i.kt)("p",null,"You may notice that Substrate specifically uses ",(0,i.kt)("em",{parentName:"p"},"unsigned")," for many data types which are represented\nfor a number. An example of this is a ",(0,i.kt)("inlineCode",{parentName:"p"},"BlockNumber"),", which is a ",(0,i.kt)("inlineCode",{parentName:"p"},"u32"),", or even the type for an\naccount balance, which is usually represented as ",(0,i.kt)("inlineCode",{parentName:"p"},"u128"),"."),(0,i.kt)("p",null,"Unsigned types cannot be negative, meaning that all primitives used within a runtime are all\npositive integers. This is party due to a few reasons:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The notion of a negative balance does not exist for on-chain balances. Even for a ",(0,i.kt)("inlineCode",{parentName:"li"},"BlockNumber"),",\na negative block number is invalid and unreasonable in any scenario."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"u32")," and other unsigned types give a higher, ",(0,i.kt)("em",{parentName:"li"},"positive")," bound than a type like ",(0,i.kt)("inlineCode",{parentName:"li"},"i32"),". With\n",(0,i.kt)("inlineCode",{parentName:"li"},"BlockNumber")," as an example. This would allow the total number of blocks a network could generate\nto be much higher than a signed type.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("mdxAdmonitionTitle",{parentName:"admonition"},"Thought exercise: if Polkadot used ",(0,i.kt)("inlineCode",{parentName:"mdxAdmonitionTitle"},"u8")," for the BlockNumber type, how long would the chain"),(0,i.kt)("p",{parentName:"admonition"},"run before it overflowed?"),(0,i.kt)("p",{parentName:"admonition"},"Give it some thought, and pick an answer! What would a ",(0,i.kt)("em",{parentName:"p"},"smaller")," data type imply for something like\n",(0,i.kt)("inlineCode",{parentName:"p"},"BlockNumber"),", which the network uses to progress?"),(0,i.kt)("details",{class:"wrong"},(0,i.kt)("summary",null,(0,i.kt)("b",null,"It wouldn't overflow; the error would be handled")),"Not quite - integer overflows can happen regardless of whether it is handled or not.  A more serious implication is at play here - if the chain's height is bound by a small number type, then that is effectively the maximum number of blocks that can be kept track of."),(0,i.kt)("details",{class:"correct"},(0,i.kt)("summary",null,(0,i.kt)("b",null,"After the limit of ",(0,i.kt)("code",null,"u8::MAX")," blocks")),(0,i.kt)("p",{parentName:"admonition"},"Correct!"),(0,i.kt)("p",{parentName:"admonition"},"The limit of a ",(0,i.kt)("inlineCode",{parentName:"p"},"u8::MAX")," would indicate the limit for the blockchain, and thus how many blocks can\nbe generated."))),(0,i.kt)("h3",{id:"context-driven-types"},"Context-driven types"),(0,i.kt)("p",null,"In runtime development, data types should be chosen more carefully. Because a runtime instance is\nanticipated to run for a long period of time, ideally without too many breaking upgrades,\nfundamental primitives and their underlying types must be able to withstand different scenarios or\nnetwork load."),(0,i.kt)("p",null,"They can have a direct impact on the chain itself; from the state and how those types are stored, to\nthe chain's continued operation and ensuring it can run for an amount of time without interruption."),(0,i.kt)("h2",{id:"a-deeper-look-at-scalar--compound-types"},"A Deeper Look at Scalar & Compound Types"),(0,i.kt)("h3",{id:"type-aliases"},"Type Aliases"),(0,i.kt)("p",null,"Type aliases are used to shorten long, generic types. For example, the following is how one may\naccess a balance from an interface exposed by the balances' pallet in Substrate:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"}," type BalanceOf<T> = <<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;\n")),(0,i.kt)("p",null,"This type alias truncates a long(er) type which is used to access the Balances interface from one of\nthe most widely used pallets, ",(0,i.kt)("inlineCode",{parentName:"p"},"pallet_balance"),". You may notice type aliasing being used quite\nfrequently, as this greatly aids in code readability and saves the trouble of typing!"),(0,i.kt)("h3",{id:"regarding-sized-types"},'Regarding "Sized" Types'),(0,i.kt)("p",null,"In Rust, all types are either ",(0,i.kt)("em",{parentName:"p"},"sized")," or ",(0,i.kt)("em",{parentName:"p"},"unsized"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Sized")," is a trait which is implicitly placed on\nevery type with a known, constant type at compile time. In Rust, the notion of a type being ",(0,i.kt)("inlineCode",{parentName:"p"},"Sized"),"\nrefers to whether or not its reasonably able to tell the size at compile time. Unsized types, such\nas dynamically sized typed, are stored on the heap and referenced via a pointer."),(0,i.kt)("admonition",{title:"Why would a type be 'unsized'?",type:"info"},(0,i.kt)("p",{parentName:"admonition"},"As stated previously, Rust is a ",(0,i.kt)("strong",{parentName:"p"},"statically")," typed language, meaning variables (amongst other\ntokens within the language) must be known at compile time."),(0,i.kt)("p",{parentName:"admonition"},"However, especially in more trait-oriented code bases you may be dealing with ",(0,i.kt)("strong",{parentName:"p"},"dynamically sized\ntypes"),", which while useful for demonstrating polymorphic and scalable code, it can introduce some\nextra complexities in consuming those particular APIs.")),(0,i.kt)("p",null,"All local variables, functions parameters, const items, and static items (variables on the stack)\nmust be ",(0,i.kt)("inlineCode",{parentName:"p"},"Sized"),"."),(0,i.kt)("p",null,"Luckily, the pointer type in Rust is always ",(0,i.kt)("inlineCode",{parentName:"p"},"Sized")," - this is why we are able to declare ",(0,i.kt)("inlineCode",{parentName:"p"},"&str"),", but\ncannot use ",(0,i.kt)("inlineCode",{parentName:"p"},"str"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'let sized_str: &str = ""; // string literals always default to &str\n')),(0,i.kt)("p",null,"If we dereference ",(0,i.kt)("inlineCode",{parentName:"p"},"sized_str"),", which will give us ",(0,i.kt)("inlineCode",{parentName:"p"},"str"),", the compiler will throw an error indicating\nthat it cannot possibly know the size of ",(0,i.kt)("inlineCode",{parentName:"p"},"str"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'let unsized_str: str = *""; // string literals always default to &str\nerror[E0277]: the size for values of type `str` cannot be known at compilation time\n   |\n   |     let let unsized_str: str = *"";\n   |         ^^^^^^ doesn\'t have a size known at compile-time\n   |\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"str")," on its own is actually an undefined slice of ",(0,i.kt)("inlineCode",{parentName:"p"},"u8"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"[u8]"),". This does not have a defined\nsize, which is why ",(0,i.kt)("inlineCode",{parentName:"p"},"&str")," must be used. ",(0,i.kt)("inlineCode",{parentName:"p"},"&str")," ",(0,i.kt)("em",{parentName:"p"},"refers")," to the actual slice of bytes stored on the\nheap with a pointer, which ",(0,i.kt)("em",{parentName:"p"},"is")," ",(0,i.kt)("inlineCode",{parentName:"p"},"Sized"),"."),(0,i.kt)("h3",{id:"why-does-this-matter"},"Why does this matter?"),(0,i.kt)("p",null,"This section may seem out of place, but later when dealing with more exotic and dynamic types, such\nas in the context of Substrate, this will aid in understanding the decisions of the various APIs\nthat Substrate exposes. Trait objects (and their respective virtual tables), smart pointers, and\nother dynamically sized types all become more commonplace in bigger projects that allow for more\ndecisions centered around the types of the APIs themselves to take place."),(0,i.kt)("p",null,"Rust comes with different ways to deal with unsized types, which become increasingly more\ncommonplace when dealing with more generic codebases, where not all items are completely defined."))}u.isMDXComponent=!0}}]);