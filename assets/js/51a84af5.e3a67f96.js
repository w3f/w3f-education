"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[1158],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,h=m["".concat(l,".").concat(d)]||m[d]||c[d]||a;return n?i.createElement(h,o(o({ref:t},p),{},{components:n})):i.createElement(h,o({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var u=2;u<a;u++)o[u]=n[u];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3378:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return p},default:function(){return m}});var i=n(7462),r=n(3366),a=(n(7294),n(3905)),o=["components"],s={id:"functions-comments",title:"Functions & Comments in Rust",sidebar_label:"Functions & Comments",description:"Learn how functions and comments work, and how to create them in Rust."},l=void 0,u={unversionedId:"Rust/section2/functions-comments",id:"Rust/section2/functions-comments",isDocsHomePage:!1,title:"Functions & Comments in Rust",description:"Learn how functions and comments work, and how to create them in Rust.",source:"@site/docs/Rust/section2/functions-comments.md",sourceDirName:"Rust/section2",slug:"/Rust/section2/functions-comments",permalink:"/w3f-education/docs/Rust/section2/functions-comments",editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Rust/section2/functions-comments.md",version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1679608425,formattedLastUpdatedAt:"3/23/2023",frontMatter:{id:"functions-comments",title:"Functions & Comments in Rust",sidebar_label:"Functions & Comments",description:"Learn how functions and comments work, and how to create them in Rust."},sidebar:"rust",previous:{title:"Data Types",permalink:"/w3f-education/docs/Rust/section2/data-types"},next:{title:"Loops & Basic Logic Flows",permalink:"/w3f-education/docs/Rust/section2/loops"}},p=[{value:"Parameters",id:"parameters",children:[]},{value:"Statements and Expressions",id:"statements-and-expressions",children:[]},{value:"Return types",id:"return-types",children:[]},{value:"Try it out!",id:"try-it-out",children:[]},{value:"What is happening here?",id:"what-is-happening-here",children:[]}],c={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,o);return(0,a.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"With the knowledge of variables and data types, it is time to put them to use.  ",(0,a.kt)("strong",{parentName:"p"},"Functions")," in Rust should be familiar.  The ",(0,a.kt)("inlineCode",{parentName:"p"},"main")," function is one, for example, that you have already seen several times in the Rust Playground."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// This is a function!\nfn main() {}\n")),(0,a.kt)("p",null,"Functions contain pieces of logic in a context-specific scope.  They are useful for splitting your program into more digestible pieces rather than just using a single main function to operate."),(0,a.kt)("p",null,"Declaring a function is simple - start with ",(0,a.kt)("inlineCode",{parentName:"p"},"fn"),", followed by the name and two empty parentheses, and closed with curly brackets:  "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    // The main function is no longer alone here.\n    do_something_interesting();\n}\n\nfn do_something_interesting() {\n    println!("Something interesting!");\n}\n')),(0,a.kt)("p",null,"You may have noticed that we called the ",(0,a.kt)("inlineCode",{parentName:"p"},"do_something_interesting()")," function within our main function.  It doesn't matter where this function is declared or what it does.  It will execute as long as it's valid, safe Rust code."),(0,a.kt)("h2",{id:"parameters"},"Parameters"),(0,a.kt)("p",null,"Functions in this form aren't useful.  The above is pointless; we could accomplish the same result with less code."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Parameters")," allow for functions to have more dynamic and custom input.  For example, let's take the previous example and add a parameter:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    // The main function is no longer alone here.\n    do_something_interesting(true);\n}\n\nfn do_something_interesting(is_interesting: bool) {\n    println!("Is this interesting: {is_interesting}.");\n}\n// Output: Is this interesting: true.\n')),(0,a.kt)("p",null,"A parameter is added within the previously empty parentheses.  It takes the name, ",(0,a.kt)("inlineCode",{parentName:"p"},"is_interesting")," followed by a colon (",(0,a.kt)("inlineCode",{parentName:"p"},":"),"), and the type, ",(0,a.kt)("inlineCode",{parentName:"p"},"bool"),".  This tells the function that it also expects a boolean to be included as a parameter when it is called.  These parameters become part of the ",(0,a.kt)("em",{parentName:"p"},"function's signature"),", or the unique layout of the function."),(0,a.kt)("p",null,"You can include multiple parameters of multiple types:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    // The main function is no longer alone here.\n    do_something_interesting(true, "Bader");\n}\n\nfn do_something_interesting(is_interesting: bool, name: &str) {\n    println!("Hey, {name}!  Is this interesting: {is_interesting}.");\n}\n// Output: Hey, Bader!  Is this interesting: true.\n')),(0,a.kt)("h2",{id:"statements-and-expressions"},"Statements and Expressions"),(0,a.kt)("p",null,"It's essential to differentiate ",(0,a.kt)("strong",{parentName:"p"},"statements")," versus ",(0,a.kt)("strong",{parentName:"p"},"expressions")," in Rust.  Functions in Rust are ",(0,a.kt)("strong",{parentName:"p"},"statements")," that can end in an ",(0,a.kt)("strong",{parentName:"p"},"expression"),".  The difference is: "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"Statements")," perform some modification and do not return any value."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("em",{parentName:"li"},"Expressions")," provide a conclusion in the form of a value.")),(0,a.kt)("p",null,"A simple way to think about this is when you declare something purely definitive in Rust, whether a variable or a function, it is a ",(0,a.kt)("strong",{parentName:"p"},"statement"),".  "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// This is a statement - it states that x is `10` and does not return anything.\nlet x = 10;\n")),(0,a.kt)("p",null,"For expressions, they must evaluate and ",(0,a.kt)("strong",{parentName:"p"},"express")," a final value.  Take this example: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// Defining a new scope within main.\nlet y = {\n    let x = 3;\n    x + 1 // An expression that returns 4\n};\n\n")),(0,a.kt)("p",null,"Notice the lack of a semicolon at the end of ",(0,a.kt)("inlineCode",{parentName:"p"},"x + 1"),".  As soon as you add a semicolon to a line's end, it becomes a statement.  Expressions do not have semicolons appended to the end of them."),(0,a.kt)("h2",{id:"return-types"},"Return types"),(0,a.kt)("p",null,"A key part of functions in Rust is the ability to specify a return type.  With the knowledge that we can use expressions to have a conclusion to a series of operations, we can use the following syntax to add a return type and result to our function: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// This function takes a number and returns the squared version of it.\nfn square(x: i32) -> i32 {\n    x * x\n}\n")),(0,a.kt)("p",null,"Notice the return type is denoted by the arrow (",(0,a.kt)("inlineCode",{parentName:"p"},"->"),") followed by the type we wish to return.  To return the type, we simply return the expression without a semicolon.  It's possible to also explicitly define a return statement:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// This function takes a number and returns the squared version of it.\nfn square(x: i32) -> i32 {\n    // This is also valid!\n    return x * x;\n}\n")),(0,a.kt)("h1",{id:"comments"},"Comments"),(0,a.kt)("p",null,"Comments are used to document parts of your code in order to provide clarification when needed.  Not every line needs to be commented on.  However, it may be helpful to provide context in certain situations.  Double forward slashes usually precede them (",(0,a.kt)("inlineCode",{parentName:"p"},"//"),")."),(0,a.kt)("p",null,"Comments are purely for developers and not realized in the compiler."),(0,a.kt)("p",null,"You have already seen comments in action within the examples in this course.  Take the previous example: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    // The main function is no longer alone here.\n    do_something_interesting(true, "Bader");\n}\n// Hey, I\'m a comment!  I explain things\n// This function does something interesting, apparently.\nfn do_something_interesting(is_interesting: bool, name: &str) {\n    println!("Hey, {name}!  Is this interesting: {is_interesting}.");\n}\n// Output: Hey, Bader!  Is this interesting: true.\n')),(0,a.kt)("p",null,"In the last module, you'll learn how to properly document your code using comments in a way that Cargo can understand."),(0,a.kt)("h2",{id:"try-it-out"},"Try it out!"),(0,a.kt)("iframe",{width:"100%",height:"580",src:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn+main%28%29+%7B%0A++++%2F%2F+The+main+function+is+no+longer+alone+here..%0A++++do_something_interesting%28true%2C+%22Bader%22%29%3B%0A++++%2F%2F+Make+sure+to+call+your+function+here%21%0A%7D%0A%2F%2F+Hey%2C+I%27m+a+comment%21+I+explain+things%0A%2F%2F+This+function+does+something+interesting%2C+apparently.%0Afn+do_something_interesting%28is_interesting%3A+bool%2C+name%3A+%26str%29+%7B%0A++++println%21%28%22Hey%2C+%7Bname%7D%21++Is+this+interesting%3A+%7Bis_interesting%7D.%22%29%3B%0A%7D%0A%0A%0A%2F%2F+Change+this+function+to+take+a+parameter%2C+which+is+a+floating+point+number%0A%2F%2F+with+double+precison%2C+and+print+it.++%0A%2F%2F+Then%2C+call+it+in+the+main+function+and+run%21%0Afn+do_something_better%28%29+%7B%7D%0A"}),(0,a.kt)("h2",{id:"what-is-happening-here"},"What is happening here?"),(0,a.kt)("p",null,"A new function with zero parameters is introduced, called ",(0,a.kt)("inlineCode",{parentName:"p"},"do_something_better"),".  You should be able to add a new parameter of type ",(0,a.kt)("inlineCode",{parentName:"p"},"f64")," (for double precision) like so:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'\nfn do_something_better(number: f64) {\n    println("{number}");\n}\n\n')),(0,a.kt)("p",null,"To expand it, let's specify a return type - in this case, we want to return the number we passed in but squared:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"\nfn do_something_better(number: f64) -> f64 {\n    number * number\n}\n\n")),(0,a.kt)("p",null,"Notice the lack of a semicolon, which denotes a resultant value in the form of an expression."))}m.isMDXComponent=!0}}]);