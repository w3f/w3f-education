<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Rust/section3/module3">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">3. Intro to Intermediate Rust | Polkadot Education Initiative</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://education.web3.foundation/docs/Rust/section3/module3"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="3. Intro to Intermediate Rust | Polkadot Education Initiative"><meta data-rh="true" name="description" content="Structs. Enums. Methods. Packages and Crates."><meta data-rh="true" property="og:description" content="Structs. Enums. Methods. Packages and Crates."><link data-rh="true" rel="icon" href="/img/favicon-32x32.png"><link data-rh="true" rel="canonical" href="https://education.web3.foundation/docs/Rust/section3/module3"><link data-rh="true" rel="alternate" href="https://education.web3.foundation/docs/Rust/section3/module3" hreflang="en"><link data-rh="true" rel="alternate" href="https://education.web3.foundation/docs/Rust/section3/module3" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Polkadot Education Initiative RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Polkadot Education Initiative Atom Feed"><link rel="stylesheet" href="/assets/css/styles.17fa0217.css">
<link rel="preload" href="/assets/js/runtime~main.a0202557.js" as="script">
<link rel="preload" href="/assets/js/main.d449bc8e.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/w3f_logo.svg" alt="Polkadot Education Initiative" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/w3f_logo.svg" alt="Polkadot Education Initiative" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Technical Education</b></a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Courses</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/introblock">Blockchain</a></li><li><a class="dropdown__link" href="/docs/introdot">Polkadot</a></li><li><a class="dropdown__link" href="/docs/introrust">Rust Programming</a></li><li><a class="dropdown__link" href="/docs/introsubstrate">Substrate</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Resources</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/introatoz">A - Z ELI5 series </a></li><li><a class="dropdown__link" href="/docs/polkadotFAQ">Polkadot FAQ </a></li></ul></div><a class="navbar__item navbar__link" href="/blog">Blog</a><a href="https://wiki.polkadot.network/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Wiki</a><a href="https://github.com/w3f/w3f-education" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><main class="docMainContainer_gTbr docMainContainerEnhanced_Uz_u"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>3. Intro to Intermediate Rust</h1><p>Structs. Enums. Methods. Packages and Crates.
Cargo feature - this will be important for the “std” features all over Substrate. “runtime-benchmarks” and “try-runtime”.</p><p>In this module we will begin to explore Rust&#x27;s type system. We will create our own types and add methods to those types. We will also take our first look at Generics and Traits in Rust. There will be much more to cover about the type system later in the course, but in this module we will learn the most fundamental and common aspects.</p><p>Rust allows users to create two different broad categories of types. First, there are Structs which are sometimes known as &quot;product types&quot; or &quot;each-of types&quot; because a struct instance requires data in each of its fields. Second, there are Enums which are sometimes known as &quot;sum types&quot; or &quot;one-of types&quot; because an enum instance is one of multiple variants.</p><p>If you come from an object oriented programming background, structs will be familiar as they are pretty similar to the data fields on a class or object. If you come from an functional programming background, both structs and enums will likely be familiar, although the enum syntax is unlike that of OCaml or Haskell.</p><h1>Structs</h1><p>Structs allow packaging multiple primitive data types together into a logical package. They are very similar to the tuples we saw previously, although they make the language much more programmer friendly.</p><p>When defining a struct, you provide a name for the type, which has a capital letter by convention. Then you provide a name for each field and a type for each field.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To create an instance of a struct, you use the name of the type and the name of each field as before. But instead of specifying a type for each field, which has already been defined, we supply a value for each field.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let one_half = Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Structs, like tuples, need to have a value for each and every field. It is not valid to omit one of the fields.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let one = Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Similarly, each field must be of the type that was declared when the struct was defined.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let one_half = Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: 1u64,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: 2u64,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now that we know how declare and instantiate structs, let&#x27;s see how to access their fields. To access the inner data of a struct, we just use a dot operator and then the name of the field.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let my_frac = Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: 3,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let my_bottom_value = my_frac.denominator;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">assert!(my_bottom_value == 3);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Notice that here we have used simple integer literals like <code>3</code> as opposed to explicitly typed ones like <code>3u32</code>. This is allowed because the Rust compiler knows that the fields of the <code>Fraction</code> type are <code>u32</code> because they were declared as such. Similarly, the compiler can infer that the type of <code>my_bottom_value</code> is u32 so we don&#x27;t need an explicit annotation.</p><p>We can use the same syntax to mutate the value of a field. But, as always in Rust, to make a value mutable it must be explicitly declared as such.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let mut f1 = Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let f2 = Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// here we can mutate the denominator of f1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">f1.denominator = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// but this line will not compile because f2 is immutable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">f2.denominator = 4;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>Tuple Structs</h1><p>In some cases you want to give your type a name like you can with structs, but you don&#x27;t want to give each field a name. One such example would be storing a point on a 2D lattice.</p><p>So far we&#x27;ve learned two ways to store this data, both of which work, but neither of which are exactly what we want. We could simply use a tuple, but this does not allow us
to name the type, and could lead to confusion and even bugs if tuples are used in another context in the program.
Or we could use a struct, but this require repeating field names often when the position is a well-established mathematical convention.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// We could simply use a tuple.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let point = (2u32, 3u32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// We could use a struct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Point {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x_coord: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    y_coord: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>For cases like this, Rust has the tuple struct. This allows us to name the type while referencing the fields positionally.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Point(u32, u32);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>When using tuple structs, the fields are accessed with the dot operator and an integer index exactly like they are when working with tuples.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let buried_treasure = Point(4, 5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let treasure_x_coord = buried_treasure.0;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>It is also possible to create tuple structs with a single element inside. You may wonder why you would ever want to do this when you could simply use the underlying type directly, but in fact this is done frequently, and is often referred to as the &quot;new type pattern&quot;. The new type pattern allows us the leverage Rust&#x27;s type system to distinguish values of different semantic units even if they are represented digitally by the same underlying primitive type.</p><p>A typical example would be something like storing Temperature data when you want to be sure that the units are in Celsius as opposed to something like Kelvin or Fahrenheit.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/// A temperature value that is stored in the celsius units.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Celsius(u32);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>As a side note, notice the comment starting with a triple slash here. This is known as a doc comment or a documentation comment. Doc comments can precede data types, functions, and many other pieces of code and be used to generate automated documentation. We will not explore this in depth here, but know that it is good practice to use doc comments when creating your own types.</p><p>Finally, it is possible to create unit structs that have no fields at all. They are analogous to Rust&#x27;s built-in unit type <code>()</code>. This is useful when you want a type to declare static methods on. We will cover methods later in this module.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/// A unit type that has no data fields.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct MyUnitType;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>Custom types in Functions and Other Types</h1><p>Now that we&#x27;ve created some custom types of our own, let&#x27;s see some ways that they can be used.</p><p>One way we can use our custom types is as parameters to functions. Let&#x27;s define a function that allows us to multiply two fractions.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn multiply_fractions(a: Fraction, b: Fraction) -&gt; Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        numerator: a.numerator * b.numerator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        denominator: a.denominator * b.denominator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Now we are ready to see the value of the new type pattern we discussed previously. Consider steam engine control circuit with a function that determines whether the boiler has warmed up enough to start the engine.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/// First attempt that is subject to unit confusion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn warm_enough(temp: u32) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    temp &gt; 100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In this naive function we run the risk of a user entering a Fahrenheit temperature by mistake, or interfacing with a temperature probe that is incorrectly configured to report Fahrenheit temperature.</p><p>We can make this function safer by using Rust&#x27;s type system to insist that a Celsius temperate is entered. This program will not even compile if a plain u32 is passed.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Celsius(u32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn warm_enough(temp: Celsius) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    temp.0 &gt; 100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Another place we can use our custom types is as fields of other custom types. Consider a geometry program that builds up shapes from more fundamental primitive types.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Point(u32, u32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// We define a Rectangle by its two opposite corners</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Rectangle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    top_left: Point,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bottom_right: Point,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>Enums</h1><p>TODO</p><h1>Methods</h1><p>We saw previously how we can write functions that take our custom data types as parameters or return our custom data types. Rust also supports the notion of a method. A method is a special function that is defined in the context of a particular type.</p><p>If you are familiar with Object Oriented languages like Java, methods will be very familiar. In Rust, methods are defined in a separate block than the type itself, unlike Java where the methods and data are all part of the same class. This adds some flexibility to Rust as we will see. Methods always take function </p><p>Methods are very similar to functions in syntax. The only difference is that they go in an <code>impl</code> block. As an illustrative example, lets re-write the <code>multiply_fraction</code> function the we looked at earlier as a method.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// Multiply two fractions together, and return the Product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// as a third new fraction</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn multiply(self, other: Fraction) -&gt; Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            numerator: self.numerator * other.numerator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            denominator: self.denominator * other.denominator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This method is very similar to the function we wrote previously. The main difference is the first parameter, <code>self</code>. Notice that this <code>self</code> has a lowercase s like any other variable name and no type annotation. The first parameter of a method is always an instance of the type that the method is associated with, in this case Fraction, and it is always called <code>self</code>. Otherwise this method is the same as our previous standalone function.</p><p>To call this method, we call it <em>on</em> an instance of the type using dot notation like in many other languages.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let f1 = Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let f2 = Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let f3 = f1.multiply(f2);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>One weakness of the method as it is written above is that it takes ownership of both of the original fractions, and consequently, de-allocates them when it returns. A better signature would only borrow the two original fractions.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// Multiply two fractions together, and return the Product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// as a third new fraction</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn multiply(&amp;self, other: &amp;Fraction) -&gt; Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            numerator: self.numerator * other.numerator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            denominator: self.denominator * other.denominator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In the previous two versions of this function, we&#x27;ve explicitly listed the type with which the function is associated, namely, <code>Fraction</code>, several times. While this is perfectly valid Rust, it is also possible to use the type <code>Self</code> which has a capital S like other types in Rust. The <code>Self</code> is only available in the context of an <code>impl</code> block, and it refers to whatever type the function is associated with. Here&#x27;s how the function looks when we use the <code>Self</code> type.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// Multiply two fractions together, and return the Product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// as a third new fraction</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn multiply(self, other: Self) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            numerator: self.numerator * other.numerator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            denominator: self.denominator * other.denominator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>It is also valid, although not particularly idiomatic, to mix some uses of <code>Self</code> with some uses of <code>Fraction</code>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="api-methods">API Methods<a href="#api-methods" class="hash-link" aria-label="Direct link to API Methods" title="Direct link to API Methods">​</a></h2><p>We&#x27;ve seen already that we can access fields of our <code>Fraction</code> type by using the dot operator and the name of the field. However, this only works if we are in the same module that defines the struct, or if thei fields are declared as public with the <code>pub</code> keyword. We will discuss visibility and API design later in this unit. But for now, know that it is often not possible to access the fields of types that are defined in foreign code.</p><p>Rather, it is often the case that a programmer-friendly API is defined on the types to prevent accidentally introducing inconsistent data. Some of the most common such methods are accessor and modifier methods aka &quot;getters&quot; and &quot;setters&quot;.</p><p>Continuing the example of our <code>Fraction</code> type, such methods would look like this.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// Access the numerator of a given fraction</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn get_numerator(&amp;self) -&gt; u32{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.numerator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// Change the numerator of a given fraction</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn set_numerator(&amp;mut self, new_numerator: u32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.numerator = new_numerator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The getter method should contain no surprises as all the relevant concepts were already introduced in our multiply fractions example. The setter however demonstrates that methods can borrow the <code>self</code> parameter mutably. Because the <code>set_numerator</code> method will mutate the fraction on which it is called, it can only be called if the fraction was defined as mutable with the <code>mut</code> keyword.</p><p>The setter and getter methods very common and very important, but they are also somewhat trivial. Let&#x27;s consider a more interesting method, one to reduce a fraction to its simplified form. Here we will focus on the signature of the function, and leave the implementation to you, the learner, as an exercise. Notice that it is perfectly acceptable to have multiple <code>impl</code> blocks for the same type.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// Reduce a Fraction in-place by mutating its numerator and denominator.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn reduce(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Implementation left as an exercise.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Like the setter, this method may mutate the fields of the fraction, and thus the signature indicates a mutable borrow.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="associated-functions">Associated Functions<a href="#associated-functions" class="hash-link" aria-label="Direct link to Associated Functions" title="Direct link to Associated Functions">​</a></h2><p>Finally we will discuss the concept of associated function. In fact, all methods are associated functions. But not all associated functions are methods. You may remember I said previously that all methods take an instance of the type called <code>self</code> as the first parameter. Well a function may still appear in an <code>impl</code> block without this <code>self</code> parameter, and such functions are called associated functions, but they are not called method.</p><p>CAUTION: The jargon here is different than Java. In Java, methods without the <code>this</code> (analogous to <code>self</code>) parameter are still called methods. In fact they are called static methods. Although the language is different, the concepts are still the same. And if you use the term &quot;static method&quot; Rust programmers are likely to know what you mean, although doing so is technically incorrect.</p><p>As an example of a static method, let&#x27;s consider the API we might provide for a consumer of our Fraction library to create a new fraction.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new(numerator: u32, denominator: u32) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Self{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            numerator: numerator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            denominator: denominator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This function is very straight forward, and simply puts the supplied data into the appropriate fields.</p><p>I&#x27;ll take this opportunity to mention a short-hand syntax that is available in Rust and makes the life of the programmer a little nicer. In our new function, we had local variables called <code>numerator</code> and <code>denominator</code> and we put them into fields with exactly the same names. When assigning a field from a local variable with exactly, the same name, it is valid Rust to elide the field name entirely, and only put the value. The compiler knows what field you are using based on the variable name.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Fraction {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn new(numerator: u32, denominator: u32) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Self{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            numerator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            denominator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>Generics</h1><p>Many of the types we&#x27;ve defined in this module are more restrictive than they need to be. For example, our Fraction type insists that its inner values be of type <code>u32</code>. It may be that in some cases, programmers want more precision and prefer to use <code>u64</code> instead. It would be a shame to have to re-write the entire struct and all of its methods just to change all the <code>u32</code> to <code>u64</code>.</p><p>To address this problem, Rust&#x27;s Type system has a notion of Generic types, or &quot;generics&quot; for short. Code that uses generics and related concepts can become quite complex, and we will dive into that full complexity in due course, but for now, let&#x27;s take a look at a simple use of generic types.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/// A fraction type that allows arbitrarily large or small numerators and denominators</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Fraction&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In this improved definition of our Fraction type, we do not explicitly define the type that the numerator and denominator field will be. Rather we say they will be some generic type <code>T</code>. We define the single generic type in angle brackets after the name of the struct, <code>Fraction</code>. This means that <code>T</code> can be replaced by any type we may wish to use. While <code>T</code> can indeed be any type, because both <code>numerator</code> and <code>denominator</code> are given the type <code>T</code>, that means that they must be the <em>same</em> type. They cannot be two different types; that would require two generic parameters.</p><p>When we create instances of our new generic fraction type, we must fill in the generic type.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let my_precise_fraction = Fraction&lt;u128&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: 236,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: 473,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let my_low_memory_fraction = Fraction&lt;u8&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: 4,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We have succeeded in creating a Fraction type that allows us to use any precision integer wa want! But we have also introduced a few problems here. For example, it is now possible to create fractions with data types that don&#x27;t make any sense at all. Consider this example.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let silly_fraction = Fraction&lt;bool&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Not only does this bool fraction not make any sense, we also won&#x27;t be able to multiply bool fractions together because booleans themselves can&#x27;t be multiplied. In the next video we will see how Rust&#x27;s traits solve this problem.</p><h1>Traits</h1><p>Traits are Rusts way of allowing programmers to define shared abstract behavior that may exist on multiple types. This concept is present in most modern programming languages. For example it manifests as <code>interface</code>s in Java, type classes in Haskell, and mix-ins in Ruby.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="area-example">Area Example<a href="#area-example" class="hash-link" aria-label="Direct link to Area Example" title="Direct link to Area Example">​</a></h2><p>As a first example, let&#x27;s consider a few 2D geometry types. Each of these types has different fields, but all of them are have some area, and it is valid to expect that their area can be calculated from their fields. Let&#x27;s consider a Square and a Circle for example</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Square {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    side_length: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Circle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    radius: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Any geometry program is likely to want to know the area of these various shapes. We already know how to implement an <code>area</code> method on each of them. But implementing a one-off method on each type is problematic.</p><p>One surface-level problem is that programmers might choose slightly different names for the area method on each struct.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Square {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn get_area(&amp;self) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //--snip--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Circle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn calculate_area(&amp;self) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //--snip--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>A second, more fundamental, problem is that we may want to write a function that can work with <em>any</em> object whose area can be calculated, and we need a way to express to the compiler that a particular type can have its area calculated. Traits solve both of these problems.</p><p>Let&#x27;s define a trait for any type that can have its area calculated.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Area {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn area(&amp;self) -&gt; u32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>To do this, we use the keyword <code>trait</code> and then the name of the trait which starts with a capital letter, just like types do. Inside the body of the trait, we list some function signatures, but we do not include the body. Rather we just end the signature with a semicolon. The body of the function can be different for each type that implements the trait. The concept of writing the function signature without the body should be familiar to C and C++ developers as it is similar to how header files work in those languages.</p><p>There are a few items other than just function signatures that can go inside a trait definition, but we will save that discussion for later in the course.</p><p>Let&#x27;s implement this trait for our two structs.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Area for Square {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn area(&amp;self) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.side_length * self.side_length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Area for Circle {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn area(&amp;self) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const PI: u32  = 3; // LOL. This is a good approximation, right?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PI * self.radius * self.radius</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We can see here that we have solved the shallower naming problem because the trait defines the name of the area function once for every type that implements it.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="trait-bounds-for-function-parameters">Trait Bounds for Function parameters<a href="#trait-bounds-for-function-parameters" class="hash-link" aria-label="Direct link to Trait Bounds for Function parameters" title="Direct link to Trait Bounds for Function parameters">​</a></h2><p>Now let&#x27;s see how we can solve the deeper problem of writing a function that works with any shape that can have it&#x27;s area calculated. Imagine that we want to know how many cans of paint we will need to cover a particular shape. For this we use a feature of Rust called a trait bound.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn how_many_cans&lt;T: Area&gt;(shape: T) -&gt; u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// Each can of paint covers 4 units (eg m^2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const one_can: u32 = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Get the area of the shape in question</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let area_to_paint = shape.area();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // We basically just divide. But we need to be sure there is</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // extra paint, not slightly too little paint.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (area_to_paint + one_can - 1) / one_can</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>There are a few new things happening in this function signature. The first is the presence of the generic parameter <code>T</code> in a function. We previously saw how to declare generics on a struct, and it is quite similar for functions. Any generic types go in angle brackets immediately after the name of the function. But it is more than just a generic parameter. This time we also introduce a trait bound. That&#x27;s the <code>: Area</code> part. This syntax says that while the <code>how_many_cans</code> function can be used with multiple different types, it can&#x27;t be used with just any old type. It must be used with a type that implements our <code>Area</code> trait.</p><p>By using this trait bound, we ensure that any type passed to this function implements the necessary area trait. And if you try to pass a different type, for example <code>bool</code>, then your code won&#x27;t compile.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conditional-method-implementation">Conditional Method Implementation.<a href="#conditional-method-implementation" class="hash-link" aria-label="Direct link to Conditional Method Implementation." title="Direct link to Conditional Method Implementation.">​</a></h2><p>It turns out that trait bounds are the exact tool we need to make our generic Fraction type work. Let&#x27;s take a look at how we can use trait bounds here.</p><p>As a reminder, here&#x27;s where we left our Fraction type.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Fraction&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We discussed that leaving the type <code>T</code> unbounded is a problem because a user could try to use the type <code>bool</code>. Such a fraction does not make any sense at all, but concretely it doesn&#x27;t make sense because bools, can&#x27;t be multiplied. Let&#x27;s see if the compiler can tell us that itself.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T&gt; Fraction&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// Multiply two fractions together, and return the Product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// as a third new fraction</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn multiply(&amp;self, other: &amp;Self) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            numerator: self.numerator * other.numerator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            denominator: self.denominator * other.denominator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>First notice the syntax for implementing a method on a struct that has generics. we start with <code>impl&lt;T&gt;</code> which can be understood as &quot;for all types, <code>T</code>, implement the following. Then, as before, we name the type that we are associating this method with. </p><div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">error[E0369]: cannot multiply `T` by `T`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; src/main.rs:10:39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 |             numerator: self.numerator * other.numerator,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |                        -------------- ^ --------------- T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |                        |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |                        T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">help: consider restricting type parameter `T`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5  | impl&lt;T: std::ops::Mul&lt;Output=T&gt;&gt; Fraction&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |       +++++++++++++++++++++++++</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Indeed, the compiler tells us that we &quot;cannot multiply <code>T</code> by <code>T</code>&quot;. It also offers a very helpful suggestion using the <code>Mul</code> trait from the standard library. The compiler&#x27;s suggestion will work here, and I encourage you to confirm that by making the suggested change. However, the understand the <code>Mul</code> trait, we need to first learn about associated types, which we will not cover until later in the course. So for now, let&#x27;s invent our own <code>Multiply</code> trait for any type that can be multiplied together, and implement it for a few primitive unsigned integer types.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Multiply {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn multiply(&amp;self, other: &amp;Self) -&gt; Self;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Multiply for u8 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn multiply(&amp;self, other: &amp;Self) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self * other</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Multiply for u16 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn multiply(&amp;self, other: &amp;Self) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self * other</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Multiply for u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn multiply(&amp;self, other: &amp;Self) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self * other</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Could also so u64, u128, but the point is made.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>We can now tell the compiler that our fraction multiplication method can be used for any fraction whose inner values implement this <code>Multiply</code> trait.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T: Multiply&gt; Fraction&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// Multiply two fractions together, and return the Product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// as a third new fraction</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn multiply(&amp;self, other: &amp;Self) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            numerator: self.numerator.multiply(&amp;other.numerator),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            denominator: self.denominator.multiply(&amp;other.denominator),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Of course, we now need to call the <code>multiply</code> method instead of just using the <code>*</code> operator. But the more interesting difference is the trait bound <code>T: Multiply</code>. This can be understood as &quot;For all types <code>T</code> that implement the <code>Multiply</code> trait, implement this method&quot;.</p><p>Our fraction type is now able to support multiplication as long as the inner data type also supports it, and we communicate that through a trait bound.</p><h1>Trait Bounds on Type Definitions</h1><p>In the previous video we showed how to use a trait bound on the <code>impl</code> block where we associated the <code>multiply</code> method with our Fraction type. In this video I want to dig on on what <em>exactly</em> we did there, and what we didn&#x27;t do yet.</p><p>In fact, we did <em>not</em> prohibit creating instances of type <code>Fraction&lt;bool&gt;</code>. With the code from the previous video it is still perfectly possible to create such bool fractions. But what we did do is express to the compiler that for certain generic types, it is now possible to multiply fractions together. This is an interesting and powerful feature of Rust. We were able to conditionally associate a method with our <code>Fraction&lt;T&gt;</code> type depending on whether or not its generic types meets a particular trait bound. If the generic type implements the <code>Multiply</code> trait, the the instance has a <code>multiply</code> method. But if the generic type does not implement this trait, then the method will not be associated.</p><p>Having observed this powerful aspect of Rust, you may be thinking, &quot;Yeah, that is useful and interesting, but in this case, do we really want to allow even creating weird fractions that can&#x27;t be multiplied? Well if you don&#x27;t we can express that in Rust as well. All we have to do is add... you guessed it, a trait bound... to the struct definition.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Fraction&lt;T: Multiply&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    numerator: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    denominator: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>By adding the trait bound to the struct definition, we have now made it impossible to even create a Fraction whose generic type cannot be multiplied. We do still need to leave the bound on the impl block as well though.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="implementing-multiply-for-our-fraction-type">Implementing Multiply for our Fraction type<a href="#implementing-multiply-for-our-fraction-type" class="hash-link" aria-label="Direct link to Implementing Multiply for our Fraction type" title="Direct link to Implementing Multiply for our Fraction type">​</a></h2><p>It may have occurred to you that since our Fraction type is able to be multiplied now, perhaps we should implement our Multiply trait for it rather than just associating a one-off method. I totally agree, so let&#x27;s do it. It actually only takes a small adjustment to our previous impl block.</p><div class="language-rust codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rust codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T: Multiply&gt; Multiply for  Fraction&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// Multiply two fractions together, and return the Product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /// as a third new fraction</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn multiply(&amp;self, other: &amp;Self) -&gt; Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            numerator: self.numerator.multiply(&amp;other.numerator),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            denominator: self.denominator.multiply(&amp;other.denominator),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>All we had to do was change the impl block to <code>impl</code> block. We still have the same trait bound as before, but we&#x27;ve added <code>Multiply for</code> indicating we&#x27;re now implementing a trait. Since our function signature already matched the trait&#x27;s expected signature, we are done. If we had previously called out one-off method something different like &quot;times&quot; or something, we would have to make minor adjustments there as well.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="limitation">Limitation<a href="#limitation" class="hash-link" aria-label="Direct link to Limitation" title="Direct link to Limitation">​</a></h2><p>As a final note, I&#x27;ll mention one property of Rust&#x27;s type system that sometimes feels like a limitation. You can only implement a trait for a type if <em>either</em> the trait or the type (or both) are defined in the same crate as the implementation. While this can sometimes feel like a limitation, it is actually very important to prohibit this. If we allowed implementing Foreign traits on Foreign types, then it may be that multiple conflicting implementation exist in different crates, and the compiler would be unable to catch this because it checks one crate at a time.</p><p>It is unlikely that you&#x27;ll encounter this limitation until you have a little more rust experience under your belt. But when you do encounter it, know that there is a work around, and it is to use the new type pattern that we discussed previously, and then implement the trait on your new type.</p><h1>Some Common Traits and Collections</h1><p>In this module we have discussed how to create your own types, both structs and enums, create your own traits for abstracting shared behavior, and implement your traits on your types. In this final video, we&#x27;ll take a look through some of the most common types and traits that are defined in the standard library and how you might encounter them.</p><p>TODO flesh this out.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="types">Types<a href="#types" class="hash-link" aria-label="Direct link to Types" title="Direct link to Types">​</a></h2><p>Vec
String
BTreeMap
BTreeSet - Note there are also hashtable based maps and sets with similar interfaces, but we will not be looking at them because they are not available in the Substrate Runtime.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="traits-1">Traits<a href="#traits-1" class="hash-link" aria-label="Direct link to Traits" title="Direct link to Traits">​</a></h2><p>Iterator
Display
Debug
Default</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/w3f/w3f-education/edit/main/docs/Rust/section3/module3.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2023-03-08T16:43:38.000Z">Mar 8, 2023</time></b> by <b>Bader Youssef</b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#api-methods" class="table-of-contents__link toc-highlight">API Methods</a></li><li><a href="#associated-functions" class="table-of-contents__link toc-highlight">Associated Functions</a></li><li><a href="#area-example" class="table-of-contents__link toc-highlight">Area Example</a></li><li><a href="#trait-bounds-for-function-parameters" class="table-of-contents__link toc-highlight">Trait Bounds for Function parameters</a></li><li><a href="#conditional-method-implementation" class="table-of-contents__link toc-highlight">Conditional Method Implementation.</a></li><li><a href="#implementing-multiply-for-our-fraction-type" class="table-of-contents__link toc-highlight">Implementing Multiply for our Fraction type</a></li><li><a href="#limitation" class="table-of-contents__link toc-highlight">Limitation</a></li><li><a href="#types" class="table-of-contents__link toc-highlight">Types</a></li><li><a href="#traits-1" class="table-of-contents__link toc-highlight">Traits</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Courses</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/introblock">Blockchain Fundamentals</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/introdot">Introduction to Polkadot</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/introrust">Introduction to Rust Programming</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/introsubstrate">Introduction to Substrate</a></li></ul></div><div class="col footer__col"><div class="footer__title">Links</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://wiki.polkadot.network/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Wiki<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://web3.foundation/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Website<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/Web3foundation" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/w3f/w3f-education" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Web3 Foundation. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.a0202557.js"></script>
<script src="/assets/js/main.d449bc8e.js"></script>
</body>
</html>